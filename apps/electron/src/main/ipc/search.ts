import { ipcMain } from "electron";
import fs from "node:fs";
import path from "node:path";
import fsPromises from "node:fs/promises";
import { spawnSync } from "child_process";
// @ts-expect-error no types
import fg from "fast-glob";
import { getActiveProject } from "../state";

import yaml from "js-yaml";
import removeMd from 'remove-markdown'


/**
 * Removes the autogenerated text from .void files
 */
function stripFrontmatter(markdown: string): string {
  // Check if the markdown starts with the frontmatter delimiter.
  if (markdown.startsWith("---")) {
    // Split on the delimiter.
    const parts = markdown.split("---");
    if (parts.length >= 3) {
      // parts[0] is empty, parts[1] is the frontmatter,
      // and parts[2] onward is the actual markdown content.
      return parts.slice(2).join("---").trimStart();
    }
  }
  return markdown;
}

/**
 * Recursively extracts visible text content from YAML object.
 * Handles nested content arrays and differentiates tables and requests.
 */
function extractContentFromYaml(node: any) {
  let result: string[] = [];
  if (!node) return result;
  // If array, traverse each item
  if (Array.isArray(node)) {
    for (const child of node) {
      result.push(...extractContentFromYaml(child));
    }
    return result;
  }
  if (typeof node === "object") {
    if (node.type === "table") {
      let rows:string[] = [];
      if(node.content){
        rows = extractContentFromYaml(node.content || []);
      } else if(node.rows){
        rows = extractContentFromYaml(node.rows || []);
      }
      result.push(rows.join("\n"));
    } else if (node.type === "tableRow") {
      const cells = extractContentFromYaml(node.content || []);
      result.push(cells.join(" "));
    } else if(node.type =='fileLink'){
      const filename:string= (node.attrs||{filename:''}).filename||''
      result.push(extractContentFromYaml(filename).join('\n'));
    } else if(node.type==='json_body'){
      const body:string= (node.attrs||{body:''}).body||''
      result.push(extractContentFromYaml(body).join('\n'));
    }else if (typeof node.content === "string") {
      result.push(node.content);
    } else if (node.content) {
      result.push(...extractContentFromYaml(node.content));
    }else if (node.row) {
      result.push(extractContentFromYaml(node.row).join(" "));
    }
  }
  if (typeof node === "string") result.push(node);
  return result;
}

/**
 * Converts markdown (with custom YAML code blocks) into human-readable text.
 */
async function extractReadableMarkdownText(markdownText: string) {
  // Strip the autogenerated part from top of the file
  markdownText = stripFrontmatter(markdownText);
  // Generate array dividing the raw content into normal text and void yaml.
  // return array of {type:text|void,content:content};
  const segments = splitTextSegmentsWithType(markdownText);
  const output = [];
  for (var i = 0; i < segments.length; i++) {
    const seg = segments[i];
    if (seg.type === 'text' && seg.content) {
      try {
        const result = removeMd(seg.content, {
          stripListLeaders: true,
          listUnicodeChar: '',
          gfm: true,
          useImgAltText: false
        })
        output.push(result);
      } catch (e) {
      }
    } else {
      const yamlText = seg.content.trim().replace(/^void\s*/g, '').replace(/^---\s*/g, '').replace(/\s*---$/g, '');
      try {
        const parsed = yaml.load(yamlText);
        const extracted = extractContentFromYaml(parsed);
        output.push(extracted.join("\n"));
      } catch (err) {
        console.warn("YAML parse failed:", err);
      }
    }
  }
  const combined = [...output].join("\n\n");
  return combined.trim();
}

function splitTextSegmentsWithType(text: string = '') {
  const splittedItems = text.trim().split('```');
  const segments = [];
  for (var i = 0; i < splittedItems.length; i++) {
    if (splittedItems[i].startsWith('void')) {
      segments.push({
        type: 'void',
        content: splittedItems[i].replace(/^void---\s*/g, '')
          .replace(/\s*```---$/g, '')
      });
    } else {
      segments.push({ type: 'text', content: splittedItems[i] });
    }
  }
  return segments;
}


export function registerSearchIpcHandler() {
  ipcMain.handle("search-files", async (_event, args: { query: string; matchCase: boolean; matchWholeWord: boolean }) => {
    const { query, matchCase, matchWholeWord } = args;
    const projectRoot = await getActiveProject();

    const IMAGE_EXT = ["png", "jpg", "jpeg", "gif", "webp", "avif", "svg", "bmp", "ico", "tif", "tiff", "heic", "heif"];
    const ARCHIVE_EXT = ["zip", "rar", "7z", "tar", "gz", "bz2", "xz", "tgz", "tbz2", "txz"];
    const BINARY_EXT = ["exe", "msi", "dll", "bin", "iso", "img", "dmg", "so"];
    const SKIP_EXT = [...IMAGE_EXT, ...ARCHIVE_EXT, ...BINARY_EXT, "pdf"];

    function makeSnippet(line: string, matchStartCol: number, matchLen: number, maxLen = 160) {
      const totalLen = line.length;
      if (totalLen <= maxLen) {
        return line.replace(/[\r\n\t]/g, " ");
      }

      const pad = Math.max(0, Math.floor((maxLen - matchLen) / 2));
      let sliceStart = Math.max(0, matchStartCol - pad);
      let sliceEnd = Math.min(totalLen, sliceStart + maxLen);

      if (matchStartCol + matchLen > sliceEnd) {
        const needed = matchStartCol + matchLen - sliceEnd;
        sliceStart = Math.max(0, sliceStart - needed);
        sliceEnd = Math.min(totalLen, sliceStart + maxLen);
      }

      let snippet = line.slice(sliceStart, sliceEnd).replace(/[\r\n\t]/g, " ");
      if (sliceStart > 0) snippet = "…" + snippet;
      if (sliceEnd < totalLen) snippet = snippet + "…";
      return snippet;
    }

    const escapedRaw = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pattern = query.includes(" ")
      ? matchWholeWord
        ? `\\b${escapedRaw.replace(/\s+/g, "\\s+")}\\b`
        : escapedRaw.replace(/\s+/g, "\\s+")
      : matchWholeWord
        ? `\\b${escapedRaw}\\b`
        : escapedRaw;
    const flags = matchCase ? "" : "i";
    const regex = new RegExp(pattern, flags);

    try {
      if (query.includes(" ")) throw new Error("multi-word fallback");

      const rgCandidates = ["/opt/homebrew/bin/rg", "/usr/local/bin/rg"];
      const rgPath = rgCandidates.find((p) => fs.existsSync(p)) || "rg";
      const rgArgs = [
        "--vimgrep",
        "--with-filename",
        "--line-number",
        "--column",
        "--hidden",
        "--no-ignore",
        "--text",
        "--glob",
        "!**/.git/**",
      ];

      for (const ext of SKIP_EXT) {
        rgArgs.push("--glob", `!**/*.${ext}`);
      }

      if (!matchCase) rgArgs.push("--ignore-case");
      if (matchWholeWord) rgArgs.push("--word-regexp");
      rgArgs.push(query, ".");

      const result = spawnSync(rgPath, rgArgs, { cwd: projectRoot });
      if (result.error) throw result.error;
      const stdout = result.stdout.toString();
      if (result.status === 2) throw new Error(`rg exited with status ${result.status}`);
      if (result.status === 1) return [];

      return stdout
        .trim()
        .split("\n")
        .filter(Boolean)
        .map((line) => {
          const [file, ln, col, ...rest] = line.split(":");
          const absolutePath = file.startsWith(path.sep) ? file : path.join(projectRoot, file);
          const fullLine = rest.join(":");
          const colStart = Math.max(0, Number(col) - 1);
          const matchLen = query.length;
          const preview = makeSnippet(fullLine, colStart, matchLen);
          return { path: absolutePath, line: Number(ln), preview };
        });
    } catch (err) {
      const files = await fg("**/*.*", {
        cwd: projectRoot,
        dot: true,
        ignore: ["**/.git/**", ...SKIP_EXT.map((e) => `**/*.${e}`)],
      });

      const results: { path: string; line: number; preview: string }[] = [];

      await Promise.all(
        files.map(async (relative) => {
          const fullPath = path.join(projectRoot, relative);
          let content: string='';
          try {
            content = await fsPromises.readFile(fullPath, 'utf8');
            if (relative.includes('.void')) {
              content = await extractReadableMarkdownText(content);
            }
          } catch (err) {
            console.error('Error while reading rendered content :', err);
          }

          const match = regex.exec(content);
          if (match && match.index !== undefined) {
            const matchIndex = match.index;
            const lineStart = content.lastIndexOf("\n", matchIndex - 1) + 1;
            const rawLineEnd = content.indexOf("\n", matchIndex);
            const lineEnd = rawLineEnd === -1 ? content.length : rawLineEnd;

            const lineText = content.slice(lineStart, lineEnd);
            const lineNum = content.slice(0, matchIndex).split("\n").length;
            const colStart = matchIndex - lineStart;
            const matchLen = match[0].length;

            const preview = makeSnippet(lineText, colStart, matchLen);
            results.push({ path: fullPath, line: lineNum, preview });
          }
        }),
      );
      return results;
    }
  });
}
